{
    "collab_server" : "",
    "contents" : "lrp2function = function (method, nlme.model = NULL, randomFormula, fixedFormula = NULL, \n          data, start, group, rPartFormula, weight = NULL, R = NULL, \n          control = rpart.control(), min.dev = NULL) \n{\n  if (method == \"lme\") {\n    lmeFormula <- fixedFormula\n  }\n  if (is.null(min.dev) == FALSE) {\n    if (method == \"lme\") {\n      mod <- lme(lmeFormula, data = data, random = randomFormula, \n                 correlation = R, na.action = na.omit)\n    }\n    else {\n      mod <- nlme(model = nlme.model, fixed = fixedFormula, \n                  data = data, random = randomFormula, correlation = R, \n                  na.action = na.omit, start = start, group = group)\n    }\n    control$cp <- 1 - (-2 * mod$logLik - min.dev)/(-2 * \n                                                     mod$logLik)\n  }\n  if (method == \"lme\") {\n    groupingName = attr(terms(splitFormula(randomFormula, \n                                           \"|\")[[2]]), \"term.labels\")\n    responseName = attr(terms(getResponseFormula(lmeFormula)), \n                        \"term.labels\")\n    groupingFactor = data[, names(data) == groupingName]\n    terms = attr(terms(lmeFormula), \"term.labels\")\n    continuous = !is.factor(data[, names(data) == terms[1]])\n    evaluation <- function(y, wt, parms) {\n      model = lme(lmeFormula, data = parms[groupingFactor %in% \n                                             y, ], random = randomFormula, correlation = R, \n                  na.action = na.omit)\n      if (continuous) {\n        slope = model$coefficients$fixed[2]\n      }\n      else {\n        levels = length(levels(data[, names(data) == \n                                      terms[1]]))\n        y = model$coefficients$fixed[1:levels]\n        x = 1:levels\n        slope = lm(y ~ x)$coefficients[2]\n      }\n      list(label = slope, deviance = -2 * (model$logLik))\n    }\n  }\n  else if (method == \"nlme\") {\n    groupingName = attr(terms(splitFormula(group, \"~\")[[1]]), \n                        \"term.labels\")\n    responseName = attr(terms(getResponseFormula(nlme.model)), \n                        \"term.labels\")\n    groupingFactor = data[, names(data) == groupingName]\n    evaluation <- function(y, wt, parms) {\n      model = nlme(model = nlme.model, fixed = fixedFormula, \n                   data = parms[groupingFactor %in% y, ], random = randomFormula, \n                   correlation = R, na.action = na.omit, start = start, \n                   group = group)\n      slope = 1\n      list(label = slope, deviance = -2 * (model$logLik))\n    }\n  }\n  split <- function(y, wt, x, parms, continuous) {\n    print(paste(\"splitting:\", length(unique(x)), \"values\"))\n    dev = vector()\n    xUnique = unique(x)\n    if (method == \"lme\") {\n      rootDev = lme(lmeFormula, data = parms[groupingFactor %in% \n                                               y, ], random = randomFormula, correlation = R, \n                    na.action = na.omit)$logLik\n    }\n    else if (method == \"nlme\") {\n      rootDev = nlme(model = nlme.model, fixed = fixedFormula, \n                     data = parms[groupingFactor %in% y, ], random = randomFormula, \n                     correlation = R, na.action = na.omit, start = start, \n                     group = group)$logLik\n    }\n    if (continuous) {\n      for (i in xUnique) {\n        yLeft = y[x <= i]\n        yRight = y[x > i]\n        if (length(yLeft) < control$minbucket || length(yRight) < \n            control$minbucket) {\n          dev = c(dev, 0)\n        }\n        else {\n          if (method == \"lme\") {\n            modelLeft = try(lme(lmeFormula, data = parms[groupingFactor %in% \n                                                           yLeft, ], random = randomFormula, correlation = R, \n                                na.action = na.omit), silent = TRUE)\n            modelRight = try(lme(lmeFormula, data = parms[groupingFactor %in% \n                                                            yRight, ], random = randomFormula, correlation = R, \n                                 na.action = na.omit), silent = TRUE)\n          }\n          else if (method == \"nlme\") {\n            modelLeft = try(nlme(model = nlme.model, \n                                 fixed = fixedFormula, data = parms[groupingFactor %in% \n                                                                      yLeft, ], random = randomFormula, correlation = R, \n                                 na.action = na.omit, start = start, group = group), \n                            silent = TRUE)\n            modelRight = try(nlme(model = nlme.model, \n                                  fixed = fixedFormula, data = parms[groupingFactor %in% \n                                                                       yRight, ], random = randomFormula, correlation = R, \n                                  na.action = na.omit, start = start, group = group), \n                             silent = TRUE)\n          }\n          if (any(class(modelLeft) == \"lme\") && any(class(modelRight) == \n                                                    \"lme\")) {\n            dev = c(dev, modelLeft$logLik + modelRight$logLik)\n          }\n          else {\n            dev = c(dev, 0)\n          }\n        }\n      }\n      good = rep(0, length(x))\n      for (i in 1:length(xUnique)) {\n        good[x == xUnique[i]] = dev[i]\n      }\n      good = good[1:(length(good) - 1)]\n      list(goodness = good + abs(rootDev) * (good != 0) * \n             2, direction = rep(-1, length(good)))\n    }\n    else {\n      order = rep(0, length(xUnique))\n      response = parms[, names(parms) == responseName]\n      for (i in 1:length(xUnique)) {\n        order[i] = mean(response[x == xUnique[i]], na.rm = TRUE)\n      }\n      dir = sort(order, index.return = TRUE)$ix\n      for (i in 1:(length(dir) - 1)) {\n        yLeft = y[x %in% dir[1:i]]\n        yRight = y[x %in% dir[(i + 1):length(dir)]]\n        if (length(yLeft) < control$minbucket || length(yRight) < \n            control$minbucket) {\n          dev = c(dev, 0)\n        }\n        else {\n          if (method == \"lme\") {\n            modelLeft = try(lme(lmeFormula, data = parms[groupingFactor %in% \n                                                           yLeft, ], random = randomFormula, correlation = R, \n                                na.action = na.omit), silent = TRUE)\n            modelRight = try(lme(lmeFormula, data = parms[groupingFactor %in% \n                                                            yRight, ], random = randomFormula, correlation = R, \n                                 na.action = na.omit), silent = TRUE)\n          }\n          else if (method == \"nlme\") {\n            modelLeft = try(nlme(model = nlme.model, \n                                 fixed = fixedFormula, data = parms[groupingFactor %in% \n                                                                      yLeft, ], random = randomFormula, correlation = R, \n                                 na.action = na.omit, start = start, group = group), \n                            silent = TRUE)\n            modelRight = try(nlme(model = nlme.model, \n                                  fixed = fixedFormula, data = parms[groupingFactor %in% \n                                                                       yRight, ], random = randomFormula, correlation = R, \n                                  na.action = na.omit, start = start, group = group), \n                             silent = TRUE)\n          }\n          if (any(class(modelLeft) == \"lme\") | any(class(modelLeft) == \n                                                   \"nlme\") && any(class(modelRight) == \"lme\") | \n              any(class(modelRight) == \"nlme\")) {\n            dev = c(dev, modelLeft$logLik + modelRight$logLik)\n          }\n          else {\n            dev = c(dev, 0)\n          }\n        }\n      }\n      list(goodness = dev + abs(rootDev) * (dev != 0) * \n             2, direction = dir)\n    }\n  }\n  initialize <- function(y, offset, parms = 0, wt) {\n    list(y = y, parms = parms, numresp = 1, numy = 1, summary = function(yval, \n                                                                         dev, wt, ylevel, digits) {\n      paste(\"deviance (-2logLik)\", format(signif(dev), \n                                          3), \"slope\", signif(yval, 2))\n    }, text = function(yval, dev, wt, ylevel, digits, n, \n                       use.n) {\n      if (!use.n) {\n        paste(\"m:\", format(signif(yval, 1)))\n      } else {\n        paste(\"n:\", n)\n      }\n    })\n  }\n  model <- list()\n  model.rpart = rpart(paste(groupingName, c(rPartFormula)), \n                      method = list(eval = evaluation, split = split, init = initialize), \n                      control = control, data = data, parms = data)\n  \n  \n  \n  model$rpart_out <- model.rpart\n  if (method == \"lme\") {\n    model$lmeModel = lme(lmeFormula, data = data, random = randomFormula, \n                         correlation = R, na.action = na.omit)\n    model$fixedFormula = lmeFormula\n    model$lmeFormula = lmeFormula\n  }\n  else if (method == \"nlme\") {\n    model$nlmeModel <- nlme(model = nlme.model, fixed = fixedFormula, \n                            data = data, random = randomFormula, correlation = R, \n                            na.action = na.omit, start = start, group = group)\n    model$fixedFormula <- fixedFormula\n    model$nlme.model <- nlme.model\n  }\n  model$leaf_node <- model.rpart$where\n  summary = fixed_effects = var.corr = resid.var = list()\n  for (j in 1:length(table(model.rpart$where))) {\n    \n    id <- names(table(model.rpart$where))[j] == model.rpart$where\n    \n    \n    if (method == \"lme\") {\n      model.out = lme(lmeFormula, data = data[id, ], random = randomFormula, \n                      correlation = R, na.action = na.omit)\n      summary[[as.numeric(names(table(model.rpart$where)))[j]]] <- summary(model.out)\n      fixed_effects[[as.numeric(names(table(model.rpart$where)))[j]]] <- fixed.effects(model.out)\n      var.corr[[as.numeric(names(table(model.rpart$where)))[j]]] <- model.out$modelStruct[[1]]\n      resid.var[[as.numeric(names(table(model.rpart$where)))[j]]] <- model.out$sigma\n    }\n    else if (method == \"nlme\") {\n    \n        model.out <- nlme(model = nlme.model, fixed = fixedFormula, \n                        data = data[id, ], random = randomFormula, correlation = R, \n                        na.action = na.omit, start = start, group = group)\n      summary[[as.numeric(names(table(model.rpart$where)))[j]]] <- summary(model.out)\n      fixed_effects[[as.numeric(names(table(model.rpart$where)))[j]]] <- fixed.effects(model.out)\n      var.corr[[as.numeric(names(table(model.rpart$where)))[j]]] <- model.out$modelStruct[[1]]\n      resid.var[[as.numeric(names(table(model.rpart$where)))[j]]] <- model.out$sigma\n    \n      \n      }\n  }\n  model$summary <- summary\n  model$fixed_effects <- fixed_effects\n  model$var.corr <- var.corr\n  model$resid.var <- resid.var\n  model$rpart_out <- model.rpart\n  model$randomFormula = randomFormula\n  model$R = R\n  model$method = method\n  model$data = data\n  model$groupingName = groupingName\n  model$rPartFormula = rPartFormula\n  return(model)\n}\n",
    "created" : 1506183182438.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1209236705",
    "id" : "BCF6A57C",
    "lastKnownWriteTime" : 1506183161,
    "last_content_update" : 1506183161,
    "path" : "~/Desktop/lrp2function.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}