{
    "collab_server" : "",
    "contents" : "#'\n#'\n#' Longitudinal Recursive Partitioning Plotting Function\n#'\n#'\n#' @param model A longrpart2 model.\n#' @keywords longitudinal recursive partitioning mixed effects\n#' @export\n#' @examples\n#' library(longRPart2)\n#' # example goes here\n\nlrp2Plot = function(model){\n\n  #helper sub-functions\n  param.extract = function(model) {\n    grps = length(unique(model$leaf_node))\n    fix.eff = model$fixed_effects[!sapply(model$fixed_effects,\n                                          is.null)]\n    res.var = model$resid.var[!sapply(model$resid.var, is.null)]\n    varcov1 = model$var.corr[!sapply(model$var.corr, is.null)]\n    varcov = vector(\"list\", grps)\n    for (i in 1:grps) {\n      varcov2 = corMatrix(varcov1[[i]])[[1]]\n      varcov[[i]] = varcov2 * attr(varcov2, \"stdDev\") *\n        res.var[[i]] * rep(attr(varcov2, \"stdDev\") *\n                             res.var[[i]], each = nrow(varcov2))\n      attr(varcov[[i]], \"stdDev\") = NULL\n    }\n    params = list(grps = grps, fix.eff = fix.eff, varcov = varcov,\n                  res.var = res.var)\n    return(params)\n  }\n\n\n  mean.traj = function(model, fix.eff) {\n    times = seq(range(model$data$time,na.rm=T)[1], range(model$data$time,na.rm=T)[2],\n                length.out = 1000)\n    if (model$method == \"lme\") {\n      envir.df = data.frame(matrix(nrow = length(times),\n                                   ncol = length(fix.eff) + 1))\n      colnames(envir.df) = c(\"time.scores\", names(fix.eff))\n      mean.est = numeric(nrow(envir.df))\n      envir.df[, 1] = times\n      for (i in 1:nrow(envir.df)) {\n        envir.df[i, 2:ncol(envir.df)] = fix.eff\n        mean.est[i] = envir.df[i, 2] + envir.df[i, 3] *\n          envir.df[i, 1]\n      }\n      return(mean.est)\n    }\n    else if (model$method == \"nlme\") {\n      envir.df = data.frame(matrix(nrow = length(times),\n                                   ncol = length(lhs.vars(model$fixedFormula)) + 1))\n      colnames(envir.df) = c(\"time\", lhs.vars(model$fixedFormula))\n      envir.df[, 1] = times\n      for (i in 1:nrow(envir.df)) {\n        envir.df[i, 2:ncol(envir.df)] = fix.eff\n      }\n\n      names(envir.df)[names(envir.df) == 'time'] = time.metric\n\n      mean.est = eval(getCovariateFormula(model$nlme.model)[[2]],\n                      envir.df)\n      return(mean.est)\n    }\n  }\n\n\n  conf.band = function(model, rand.eff, res.var) {\n    times = seq(range(model$data$time,na.rm=T)[1], range(model$data$time,na.rm=T)[2],\n                length.out = 1000)\n    cband = matrix(nrow = length(times), ncol = 2)\n    resids = rnorm(nrow(rand.eff), 0, sqrt(res.var))\n    if (model$method == \"lme\") {\n      for (i in 1:length(times)) {\n        ys = rand.eff[, 1] + rand.eff[, 2] * times[i]\n        sort.ys = sort(ys)\n        cband[i, 1] = sort.ys[nrow(rand.eff) * 0.025 +\n                                1]\n        cband[i, 2] = sort.ys[nrow(rand.eff) * 0.975]\n      }\n    }\n    else if (model$method == \"nlme\") {\n      for (i in 1:length(times)) {\n\n        envir.for.model = data.frame(time = times[i], rand.eff)\n        names(envir.for.model)[names(envir.for.model) == 'time'] = time.metric\n\n        ys = eval(getCovariateFormula(model$nlme.model)[[2]],\n                  envir.for.model) + resids[i]\n        sort.ys = sort(ys)\n        cband[i, 1] = sort.ys[nrow(rand.eff) * 0.025 +\n                                1]\n        cband[i, 2] = sort.ys[nrow(rand.eff) * 0.975]\n      }\n    }\n    return(cband)\n  }\n\n\n  curve.struc = function(model, grps, mean.est, cbands) {\n    curve.df = data.frame(matrix(nrow = 3000 * grps, ncol = 5))\n    names(curve.df) = c(\"y\", \"grp\", \"time\", \"node\", \"ltype\")\n    ycol = NULL\n    for (i in 1:grps) {\n      ycol = c(ycol, mean.est[[i]], cbands[[i]][, 1], cbands[[i]][,\n                                                                  2])\n    }\n    curve.df$y = ycol\n    curve.df$grp = sort(rep(1:(3 * grps), 1000))\n    curve.df$ltype = as.factor(rep(c(rep(1, 1000), rep(2,\n                                                       2000)), grps))\n    times = seq(range(model$data$time,na.rm=T)[1], range(model$data$time,na.rm=T)[2],\n                length.out = 1000)\n    curve.df$time = rep(c(rep(times, 3)), grps)\n    curve.df$node = as.factor(sort(rep(unique(model$leaf_node),\n                                       3000)))\n    return(curve.df)\n  }\n\n\n  set.seed(1234)\n\n  if (model$method == \"lme\") {\n    time.var = rhs.vars(model$fixedFormula)\n    out.name = lhs.vars(model$fixedFormula)\n  }\n  else if (model$method == \"nlme\") {\n    time.var = subset(all.vars(model$nlme.model), !(all.vars(model$nlme.model) %in%\n                                                      c(lhs.vars(model$nlme.model),lhs.vars(model$fixedFormula))))\n    out.name = lhs.vars(model$nlme.model)\n\n\n    for(k in 2:length(all.vars(model$nlme.model))){\n      for(j in ncol(model$data):1){\n        if(all.vars(model$nlme.model)[k] == colnames(model$data)[j]){\n          time.metric = (all.vars(model$nlme.model)[k])\n        }\n      }\n    }\n\n    dat = model$data\n\n    model$data$time = dat[[time.metric]]\n\n  }\n\n\n  names(model$data)[which(names(model$data) == time.var)] = \"time\"\n  params = param.extract(model)\n  mean.est = rand.eff = cbands = vector(\"list\", params$grps)\n\n  for (i in 1:params$grps) {\n\n    cov.matrix = matrix(0,length(params$fix.eff[[i]]),length(params$fix.eff[[i]]))\n    colnames(cov.matrix) = lhs.vars(model$fixedFormula)\n    rownames(cov.matrix) = lhs.vars(model$fixedFormula)\n\n\n    for(j in rownames(params$varcov[[i]])){\n      for(k in colnames(params$varcov[[i]])){\n\n        cov.matrix[j,k] = params$varcov[[i]][j,k]\n\n      }\n    }\n\n    rand.eff[[i]] = mvrnorm(10000, mu = params$fix.eff[[i]],\n                            Sigma = cov.matrix)\n    colnames(rand.eff[[i]]) = lhs.vars(model$fixedFormula)\n    mean.est[[i]] = mean.traj(model, params$fix.eff[[i]])\n    cbands[[i]] = conf.band(model, rand.eff[[i]], params$res.var[[i]])\n  }\n  curve.df = curve.struc(model, params$grps, mean.est, cbands)\n  model$data$node = model$leaf_node\n\n\n\n  model$data$groupingName =   dat[[attr(terms(splitFormula(model$group, \"~\")[[1]]),\n                                        \"term.labels\")]]\n\n  model$data$responseName =   dat[[attr(terms(getResponseFormula(model$nlme.model)),\n                                        \"term.labels\")]]\n\n  p = ggplot(data = curve.df, aes(x = time, y = y, group = grp,\n                                  color = \"black\", linetype = ltype)) + geom_smooth(se = F) +\n    theme_bw() + guides(linetype = F) + facet_wrap(~node, scales = \"free\") +\n    labs(title = paste(\"Node\"), x = time.var, y = out.name) +\n    xlim(min(curve.df$time), max(curve.df$time)) + ylim(min(c(curve.df$y,\n                                                              model$data$y)),\n                                                        max(c(curve.df$y, model$data$y))) +\n    scale_color_manual(labels = sort(unique(model$leaf_node)),\n                       values = c(\"black\")) +\n    theme(axis.line=element_line(),\n          plot.background = element_blank(),\n          panel.grid.major = element_blank(), panel.grid.minor = element_blank(),\n          panel.border = element_blank(), axis.line.x = element_line(color = \"black\"),\n          axis.line.y = element_line(color = \"black\"), legend.position = \"none\") +\n    geom_line(data = model$data, aes(x = time, y = responseName, group = groupingName,\n                                     color = \"black\", linetype = NULL), alpha = 0.2) #+\n  #facet_grid(~node)\n  return(p)\n}\n",
    "created" : 1506518291828.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3281199815",
    "id" : "667F452F",
    "lastKnownWriteTime" : 1506522889,
    "last_content_update" : 1506522889466,
    "path" : "~/GitHub/longRPart2/R/lrp2Plot.R",
    "project_path" : "R/lrp2Plot.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}