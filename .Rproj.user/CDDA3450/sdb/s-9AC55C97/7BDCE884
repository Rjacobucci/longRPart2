{
    "collab_server" : "",
    "contents" : "#'\n#'\n#' The main function that runs multiple penalty values.\n#'\n#' @param model Lavaan output object. This is a model that was previously\n#'        run with any of the lavaan main functions: cfa(), lavaan(), sem(),\n#'        or growth(). It also can be from the efaUnrotate() function from\n#'        the semTools package. Currently, the parts of the model which cannot\n#'        be handled in regsem is the use of multiple group models, missing\n#'        other than listwise, thresholds from categorical variable models,\n#'        the use of additional estimators other than\n#'        ML, most notably WLSMV for categorical variables. Note: the model\n#'        does not have to actually run (use do.fit=FALSE), converge etc...\n#'        regsem() uses the lavaan object as more of a parser and to get\n#'        sample covariance matrix.\n#' @param n.lambda number of penalization values to test.\n#' @param pars_pen parameter indicators to penalize.\n#' @param metric Which fit index to use to choose a final model?\n#'        Note that it chooses the best fit that also achieves convergence\n#'        (conv=0).\n#' @param mult.start Logical. Whether to use multi_optim() (TRUE) or\n#'         regsem() (FALSE).\n#' @param multi.iter maximum number of random starts for multi_optim\n#' @param jump Amount to increase penalization each iteration.\n#' @param lambda.start What value to start the penalty at\n#' @param alpha Mixing for elastic net\n#' @param type Penalty type. Options include \"none\", \"lasso\", \"ridge\",\n#'        \"enet\" for the elastic net,\n#'        \"alasso\" for the adaptive lasso\n#'        and \"diff_lasso\". diff_lasso penalizes the discrepency between\n#'        parameter estimates and some pre-specified values. The values\n#'        to take the deviation from are specified in diff_par. Two methods for\n#'        sparser results than lasso are the smooth clipped absolute deviation,\n#'        \"scad\", and the minimum concave penalty, \"mcp\".\n#' @param fit.ret Fit indices to return.\n#' @param fit.ret2 Return fits using only dataset \"train\" or bootstrap \"boot\"? Have to\n#'        do 2 sample CV manually.\n#' @param n.boot Number of bootstrap samples if fit.ret2=\"boot\"\n#' @param data Optional dataframe. Only required for missing=\"fiml\".\n#' @param optMethod solver to use.\n#' @param gradFun gradient function to use.\n#' @param hessFun hessian function to use.\n#' @param test.cov Covariance matrix from test dataset. Necessary for CV=T\n#' @param parallel Logical. whether to parallelize the processes running models for all\n#'        values of lambda.\n#' @param ncore Number of cores to use when parallel=TRUE\n#' @param Start type of starting values to use.\n#' @param subOpt type of optimization to use in the optimx package.\n#' @param diff_par parameter values to deviate from.\n#' @param LB lower bound vector.\n#' @param UB upper bound vector\n#' @param par.lim Vector of minimum and maximum parameter estimates. Used to\n#'        stop optimization and move to new starting values if violated.\n#' @param block Whether to use block coordinate descent\n#' @param full Whether to do full gradient descent or block\n#' @param calc Type of calc function to use with means or not. Not recommended\n#'        for use.\n#' @param nlminb.control list of control values to pass to nlminb\n#' @param max.iter Number of iterations for coordinate descent\n#' @param tol Tolerance for coordinate descent\n#' @param solver Whether to use solver for coord_desc\n#' @param quasi Whether to use quasi-Newton\n#' @param solver.maxit Max iterations for solver in coord_desc\n#' @param alpha.inc Whether alpha should increase for coord_desc\n#' @param step Step size\n#' @param momentum Momentum for step sizes\n#' @param step.ratio Ratio of step size between A and S. Logical\n#' @param line.search Use line search for optimization. Default is no, use fixed step size\n#' @param warm.start Whether start values are based on previous iteration.\n#'        This is not recommended.\n#' @param missing How to handle missing data. Current options are \"listwise\"\n#'        and \"fiml\".\n#' @param ... Any additional arguments to pass to regsem() or multi_optim().\n#' @keywords optim calc\n#' @export\n#' @examples\n#' \\dontrun{\n#' library(regsem)\n#' # put variables on same scale for regsem\n#' HS <- data.frame(scale(HolzingerSwineford1939[,7:15]))\n#' mod <- '\n#' f =~ x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + x9\n#' '\n#' outt = cfa(mod, HS)\n#'\n#' cv.out = cv_regsem(outt,type=\"ridge\", pars_pen=c(1:2,6:8), n.lambda=100)\n#' # check parameter numbers\n#' extractMatrices(outt)[\"A\"]\n#' # equivalent to\n#' mod <- '\n#' f =~ 1*x1 + l1*x2 + l2*x3 + l3*x4 + l4*x5 + l5*x6 + l6*x7 + l7*x8 + l8*x9\n#' '\n#' outt = cfa(mod,HS)\n#'\n#' cv.out = cv_regsem(outt, type=\"ridge\", pars_pen=c(\"l1\",\"l2\",\"l6\",\"l7\",\"l8\"),\n#'          n.lambda=100)\n#' summary(cv.out)\n#' plot(cv.out, show.minimum=\"BIC\")\n#' }\n\n\n\ncv_regsem = function(model,\n                     n.lambda=100,\n                     pars_pen,\n                     metric=\"BIC\",\n                     mult.start=FALSE,\n                     multi.iter=10,\n                     jump=0.002,\n                     lambda.start=0,\n                     alpha=.5,\n                     type=\"lasso\",\n                     fit.ret=c(\"rmsea\",\"BIC\"),\n                     fit.ret2 = \"train\",\n                     n.boot=20,\n                     data=NULL,\n                     optMethod=\"coord_desc\",\n                    gradFun=\"ram\",\n                    hessFun=\"none\",\n                    test.cov=NULL,\n                    parallel=FALSE,\n                    ncore=2,\n                    Start=\"lavaan\",\n                    subOpt=\"nlminb\",\n                    diff_par=NULL,\n                    LB=-Inf,\n                    UB=Inf,\n                    par.lim=c(-Inf,Inf),\n                    block=TRUE,\n                    full=TRUE,\n                    calc=\"normal\",\n                    max.iter=2000,\n                    tol=1e-5,\n                    solver=FALSE,\n                    quasi=FALSE,\n                    solver.maxit=5,\n                    alpha.inc=FALSE,\n                    step=.1,\n                    momentum=FALSE,\n                    step.ratio=FALSE,\n                    line.search=FALSE,\n                    nlminb.control=list(),\n                    warm.start=TRUE,\n                    missing=\"listwise\",\n                    ...){\n\n\n#if(fit.ret2 == \"test\"){\n#  ids <-  sample(nrow(dat),nrow(dat)/2)\n#  dat.train <- dat[ids,]\n#  dat.test <- dat[-ids,]\n#}\nfits.var=NA\nmats <- extractMatrices(model)\n\nif(is.null(pars_pen) & type!=\"none\"){\n  stop(\"for cv_regsem(), pars_pen needs to be specified\")\n}\n\nif(is.null(pars_pen)==FALSE & is.numeric(pars_pen)==FALSE){\n  pars_pen <- parse_parameters(pars_pen,model)\n}\n\n\nif(parallel == TRUE){\n  stop(\"parallel is not currently supported\")\n}\n\nif(parallel==FALSE){\npar.matrix <- matrix(0,n.lambda,length(extractMatrices(model)$parameters))\nfits <- matrix(NA,n.lambda,length(fit.ret)+2)\nfit.reg <- rep(NA,n.lambda)\nfitt.var <- matrix(NA,n.lambda,length(fit.ret))\nSHRINK2 = lambda.start\ncount = 0\ncounts=n.lambda\n#res2 <- data.frame(matrix(NA,counts,3))\n#coefs = rep(1,14)\npb <- txtProgressBar(min = 0, max = counts, style = 3)\n\nwhile(count < counts){\n  count = count + 1\n\n  # create progress bar\n\n    setTxtProgressBar(pb, count)\n\n\n  SHRINK <- SHRINK2 + jump*(count-1) # 0.01 works well & 0.007 as well with 150 iterations\n\n  if(count > 1 & all(abs(par.matrix[count-1,pars_pen])<.001)){\n    break\n  }\n\nif(mult.start==FALSE){\n\n  if(warm.start==FALSE | count == 1){\n    itt = 0\n    Start=\"lavaan\"\n  }else if(fits[count-1,2] == 0){\n    itt = 0\n    Start = par.matrix[count-1,]\n    Start[pars_pen] = Start[pars_pen]-step*jump\n  }else if(fits[count-1,2] == 99){\n    Start=\"lavaan\"\n  }else{\n    itt = itt + 1\n    Start = par.matrix[count-itt-1,]\n    Start[pars_pen] = Start[pars_pen]-itt*jump\n  }\n\n\n  if(fit.ret2 == \"train\"){\n    out <- regsem(model=model,lambda=SHRINK,type=type,data=data,\n                  optMethod=optMethod,\n                  gradFun=gradFun,hessFun=hessFun,\n                  parallel=parallel,Start=Start,\n                  subOpt=subOpt,\n                  alpha=alpha,\n                  pars_pen=pars_pen,\n                  diff_par=diff_par,\n                  LB=LB,\n                  UB=UB,\n                  par.lim=par.lim,\n                  block=block,\n                  full=full,\n                  calc=calc,\n                  tol=tol,\n                  solver=solver,\n                  quasi=quasi,\n                  solver.maxit=solver.maxit,\n                  alpha.inc=alpha.inc,\n                  step=step,\n                  max.iter=max.iter,\n                  line.search=line.search,\n                  momentum=momentum,\n                  step.ratio=step.ratio,\n                  nlminb.control=nlminb.control,\n                  missing=missing)\n  }else if(fit.ret2==\"boot\"){\n\n    fitt <- matrix(NA,n.boot,length(fit.ret))\n\n    out <- regsem(model=model,lambda=SHRINK,type=type,data=NULL,\n                  optMethod=optMethod,\n                  gradFun=gradFun,hessFun=hessFun,\n                  parallel=parallel,Start=Start,\n                  subOpt=subOpt,\n                  alpha=alpha,\n                  pars_pen=pars_pen,\n                  diff_par=diff_par,\n                  LB=LB,\n                  UB=UB,\n                  par.lim=par.lim,\n                  block=block,\n                  full=full,\n                  calc=calc,\n                  tol=tol,\n                  solver=solver,\n                  quasi=quasi,\n                  solver.maxit=solver.maxit,\n                  alpha.inc=alpha.inc,\n                  step=step,\n                  max.iter=max.iter,\n                  line.search=line.search,\n                  momentum=momentum,\n                  step.ratio=step.ratio,\n                  nlminb.control=nlminb.control,\n                  missing=missing)\n\n    for(i in 1:n.boot){\n      set.seed(i)\n      data <- as.data.frame(model@Data@X)\n\n      ids1 <- sample(1:nrow(data),nrow(data),replace=TRUE)\n\n      train <- data[ids1,]\n      test <- data[-ids1,]\n\n      colnames(train) <- model@pta$vnames$ov[[1]]\n      colnames(test) <- model@pta$vnames$ov[[1]]\n\n\n      mod1 <- lavaan(parTable(model),train)\n\n    out2 <- regsem(model=mod1,lambda=SHRINK,type=type,data=NULL,\n                  optMethod=optMethod,\n                  gradFun=gradFun,hessFun=hessFun,\n                  parallel=parallel,Start=Start,\n                  subOpt=subOpt,\n                  alpha=alpha,\n                  pars_pen=pars_pen,\n                  diff_par=diff_par,\n                  LB=LB,\n                  UB=UB,\n                  par.lim=par.lim,\n                  block=block,\n                  full=full,\n                  calc=calc,\n                  tol=tol,\n                  solver=solver,\n                  quasi=quasi,\n                  solver.maxit=solver.maxit,\n                  alpha.inc=alpha.inc,\n                  step=step,\n                  max.iter=max.iter,\n                  line.search=line.search,\n                  momentum=momentum,\n                  step.ratio=step.ratio,\n                  nlminb.control=nlminb.control,\n                  missing=missing)\n\n    if(out$convergence==0){\n\n\n      if(mats$mean == TRUE){\n        mm = mats$A[,\"1\"]\n\n        SampMean <- colMeans(test)\n        ss = match(names(mm[mm > 0]),model@Data@ov$name)\n        SampMean[-c(ss)] = 0\n\n        SampCov=cov(test)\n        SampCov2 <- SampCov + SampMean%*%t(SampMean)\n\n        # try changing size of SampCov\n        SampCov3 = cbind(SampCov2,SampMean)\n        SampCov = rbind(SampCov3,append(SampMean,1))\n\n      }else if(mats$mean == FALSE){\n        # SampCov <- model@SampleStats@cov[][[1]]\n        SampMean = NULL\n        SampCov=cov(test)\n      }\n\n      fitt[i,] = fit_indices(out2,CV=TRUE,CovMat=SampCov)$fits[fit.ret]\n\n    }else{\n      fitt[i,] = NA\n    }\n    }\n    fits[count,3:ncol(fits)] <- apply(fitt, 2, function(x) mean(x, trim = .2,na.rm=TRUE))\n    fitt.var[count,1:length(fit.ret)] <- apply(fitt, 2, function(x) var(x,na.rm=TRUE))\n  }else if(fit.ret2==\"cv\"){\n\n\n    fitt <- matrix(NA,5,length(fit.ret))\n\n    out <- regsem(model=model,lambda=SHRINK,type=type,data=NULL,\n                  optMethod=optMethod,\n                  gradFun=gradFun,hessFun=hessFun,\n                  parallel=parallel,Start=Start,\n                  subOpt=subOpt,\n                  alpha=alpha,\n                  pars_pen=pars_pen,\n                  diff_par=diff_par,\n                  LB=LB,\n                  UB=UB,\n                  par.lim=par.lim,\n                  block=block,\n                  full=full,\n                  calc=calc,\n                  tol=tol,\n                  solver=solver,\n                  quasi=quasi,\n                  solver.maxit=solver.maxit,\n                  alpha.inc=alpha.inc,\n                  step=step,\n                  max.iter=max.iter,\n                  line.search=line.search,\n                  momentum=momentum,\n                  step.ratio=step.ratio,\n                  nlminb.control=nlminb.control,\n                  missing=missing)\n\n\n    for(i in 1:5){\n      set.seed(i)\n      data <- as.data.frame(model@Data@X)\n\n      ids1 <- sample(1:nrow(data),round(nrow(data)*.80,1),replace=FALSE)\n\n      train <- data[ids1,]\n      test <- data[-ids1,]\n\n      colnames(train) <- model@pta$vnames$ov[[1]]\n      colnames(test) <- model@pta$vnames$ov[[1]]\n\n\n      mod1 <- lavaan(parTable(model),train)\n\n      out2 <- regsem(model=mod1,lambda=SHRINK,type=type,data=NULL,\n                     optMethod=optMethod,\n                     gradFun=gradFun,hessFun=hessFun,\n                     parallel=parallel,Start=Start,\n                     subOpt=subOpt,\n                     alpha=alpha,\n                     pars_pen=pars_pen,\n                     diff_par=diff_par,\n                     LB=LB,\n                     UB=UB,\n                     par.lim=par.lim,\n                     block=block,\n                     full=full,\n                     calc=calc,\n                     tol=tol,\n                     solver=solver,\n                     quasi=quasi,\n                     solver.maxit=solver.maxit,\n                     alpha.inc=alpha.inc,\n                     step=step,\n                     line.search=line.search,\n                     max.iter=max.iter,\n                     momentum=momentum,\n                     step.ratio=step.ratio,\n                     nlminb.control=nlminb.control,\n                     missing=missing)\n\n      if(out$convergence==0){\n\n\n        if(mats$mean == TRUE){\n          mm = mats$A[,\"1\"]\n\n          SampMean <- colMeans(test)\n          ss = match(names(mm[mm > 0]),model@Data@ov$name)\n          SampMean[-c(ss)] = 0\n\n          SampCov=cov(test)\n          SampCov2 <- SampCov + SampMean%*%t(SampMean)\n\n          # try changing size of SampCov\n          SampCov3 = cbind(SampCov2,SampMean)\n          SampCov = rbind(SampCov3,append(SampMean,1))\n\n        }else if(mats$mean == FALSE){\n          # SampCov <- model@SampleStats@cov[][[1]]\n          SampMean = NULL\n          SampCov=cov(test)\n        }\n\n        fitt[i,] = fit_indices(out2,CV=TRUE,CovMat=SampCov)$fits[fit.ret]\n\n      }else{\n        fitt[i,] = NA\n      }\n    }\n    fits[count,3:ncol(fits)] <- apply(fitt, 2, function(x) mean(x, trim = .2,na.rm=TRUE))\n    fitt.var[count,1:length(fit.ret)] <- apply(fitt, 2, function(x) var(x,na.rm=TRUE))\n  }\n\n\n\n\n  }else if(mult.start==TRUE){\n\n    if(warm.start==FALSE | count == 1 | count == 99){\n      itt = 0\n      Start2=\"lavaan\"\n    }else if(fits[count-1,2] == 0){\n      itt = 0\n      Start2 = par.matrix[count-1,]\n      Start2[pars_pen] = Start2[pars_pen]-step*jump\n    }else if(fits[count-1,2] == 99){\n      Start2=\"lavaan\"\n    }else{\n      itt = itt + 1\n      Start2 = par.matrix[count-itt-1,]\n      Start2[pars_pen] = Start2[pars_pen]-itt*jump\n    }\n\n\n\n\n    if(fit.ret2 == \"train\"){\n      out <- multi_optim(model=model,max.try=multi.iter,lambda=SHRINK,\n                      LB=LB,UB=UB,par.lim=par.lim,\n                      type=type,optMethod=optMethod,\n                      gradFun=gradFun,hessFun=hessFun,\n                      tol=tol,\n                      alpha=alpha,\n                      solver=solver,\n                      quasi=quasi,\n                      solver.maxit=solver.maxit,\n                      max.iter=max.iter,\n                      full=full,\n                      block=block,\n                      alpha.inc=alpha.inc,\n                      line.search=line.search,\n                      step=step,\n                      momentum=momentum,\n                      Start2=Start2,\n                      step.ratio=step.ratio,nlminb.control=nlminb.control,\n                      pars_pen=pars_pen,diff_par=NULL)\n\n    }else if(fit.ret2==\"boot\"){\n      fitt <- matrix(NA,n.boot,length(fit.ret))\n\n      out <- multi_optim(model=model,max.try=multi.iter,lambda=SHRINK,\n                         LB=LB,UB=UB,par.lim=par.lim,\n                         type=type,optMethod=optMethod,\n                         gradFun=gradFun,hessFun=hessFun,\n                         tol=tol,\n                         alpha=alpha,\n                         solver=solver,\n                         quasi=quasi,\n                         solver.maxit=solver.maxit,\n                         max.iter=max.iter,\n                         full=full,\n                         block=block,\n                         alpha.inc=alpha.inc,\n                         line.search=line.search,\n                         step=step,\n                         momentum=momentum,\n                         Start2=Start2,\n                         step.ratio=step.ratio,nlminb.control=nlminb.control,\n                         pars_pen=pars_pen,diff_par=NULL)\n\n\n      for(i in 1:n.boot){\n        set.seed(i)\n        data <- as.data.frame(model@Data@X)\n\n        ids1 <- sample(1:nrow(data),nrow(data),replace=TRUE)\n\n        train <- data[ids1,]\n        test <- data[-ids1,]\n\n        colnames(train) <- model@pta$vnames$ov[[1]]\n        colnames(test) <- model@pta$vnames$ov[[1]]\n\n        mod1 <- lavaan(parTable(model),train)\n\n        out2 <- multi_optim(model=mod1,max.try=multi.iter,lambda=SHRINK,\n                           LB=LB,UB=UB,par.lim=par.lim,\n                           type=type,optMethod=optMethod,\n                           gradFun=gradFun,hessFun=hessFun,\n                           tol=tol,\n                           alpha=alpha,\n                           solver=solver,\n                           quasi=quasi,\n                           solver.maxit=solver.maxit,\n                           max.iter=max.iter,\n                           full=full,\n                           block=block,\n                           alpha.inc=alpha.inc,\n                           line.search=line.search,\n                           step=step,\n                           momentum=momentum,\n                           Start2=Start2,\n                           step.ratio=step.ratio,nlminb.control=nlminb.control,\n                           pars_pen=pars_pen,diff_par=NULL)\n\n\n        if(out$convergence==0){\n\n\n          if(mats$mean == TRUE){\n            mm = mats$A[,\"1\"]\n\n            SampMean <- colMeans(test)\n            ss = match(names(mm[mm > 0]),model@Data@ov$name)\n            SampMean[-c(ss)] = 0\n\n            SampCov=cov(test)\n            SampCov2 <- SampCov + SampMean%*%t(SampMean)\n\n            # try changing size of SampCov\n            SampCov3 = cbind(SampCov2,SampMean)\n            SampCov = rbind(SampCov3,append(SampMean,1))\n\n          }else if(mats$mean == FALSE){\n            # SampCov <- model@SampleStats@cov[][[1]]\n            SampMean = NULL\n            SampCov=cov(test)\n          }\n\n          fitt[i,] = fit_indices(out2,CV=TRUE,CovMat=SampCov)$fits[fit.ret]\n\n        }else{\n          fitt[i,] = NA\n        }\n      }\n      fits[count,3:ncol(fits)] <- apply(fitt, 2, function(x) mean(x, trim = .2,na.rm=TRUE))\n      fitt.var[count,1:length(fit.ret)] <- apply(fitt, 2, function(x) var(x,na.rm=TRUE))\n    }else if(fit.ret2==\"cv\"){\n\n\n      fitt <- matrix(NA,5,length(fit.ret))\n\n      out <- multi_optim(model=model,max.try=multi.iter,lambda=SHRINK,\n                         LB=LB,UB=UB,par.lim=par.lim,\n                         type=type,optMethod=optMethod,\n                         gradFun=gradFun,hessFun=hessFun,\n                         tol=tol,\n                         alpha=alpha,\n                         solver=solver,\n                         quasi=quasi,\n                         solver.maxit=solver.maxit,\n                         max.iter=max.iter,\n                         full=full,\n                         block=block,\n                         alpha.inc=alpha.inc,\n                         step=step,\n                         line.search=line.search,\n                         momentum=momentum,\n                         Start2=Start2,\n                         step.ratio=step.ratio,nlminb.control=nlminb.control,\n                         pars_pen=pars_pen,diff_par=NULL)\n\n\n      for(i in 1:5){\n        set.seed(i)\n        data <- as.data.frame(model@Data@X)\n\n        ids1 <- sample(1:nrow(data),round(nrow(data)*.80,1),replace=FALSE)\n\n        train <- data[ids1,]\n        test <- data[-ids1,]\n\n        colnames(train) <- model@pta$vnames$ov[[1]]\n        colnames(test) <- model@pta$vnames$ov[[1]]\n\n\n        mod1 <- lavaan(parTable(model),train)\n\n        out2 <- multi_optim(model=mod1,max.try=multi.iter,lambda=SHRINK,\n                            LB=LB,UB=UB,par.lim=par.lim,\n                            type=type,optMethod=optMethod,\n                            gradFun=gradFun,hessFun=hessFun,\n                            tol=tol,\n                            alpha=alpha,\n                            solver=solver,\n                            quasi=quasi,\n                            solver.maxit=solver.maxit,\n                            max.iter=max.iter,\n                            full=full,\n                            block=block,\n                            alpha.inc=alpha.inc,\n                            step=step,\n                            line.search=line.search,\n                            momentum=momentum,\n                            Start2=Start2,\n                            step.ratio=step.ratio,nlminb.control=nlminb.control,\n                            pars_pen=pars_pen,diff_par=NULL)\n\n        if(out$convergence==0){\n\n\n          if(mats$mean == TRUE){\n            mm = mats$A[,\"1\"]\n\n            SampMean <- colMeans(test)\n            ss = match(names(mm[mm > 0]),model@Data@ov$name)\n            SampMean[-c(ss)] = 0\n\n            SampCov=cov(test)\n            SampCov2 <- SampCov + SampMean%*%t(SampMean)\n\n            # try changing size of SampCov\n            SampCov3 = cbind(SampCov2,SampMean)\n            SampCov = rbind(SampCov3,append(SampMean,1))\n\n          }else if(mats$mean == FALSE){\n            # SampCov <- model@SampleStats@cov[][[1]]\n            SampMean = NULL\n            SampCov=cov(test)\n          }\n\n          fitt[i,] = fit_indices(out2,CV=TRUE,CovMat=SampCov)$fits[fit.ret]\n\n        }else{\n          fitt[i,] = NA\n        }\n      }\n      fits[count,3:ncol(fits)] <- apply(fitt, 2, function(x) mean(x, trim = .2,na.rm=TRUE))\n      fitt.var[count,1:length(fit.ret)] <- apply(fitt, 2, function(x) var(x,na.rm=TRUE))\n    }\n\n  }\n  #print(pars_pen)\n # pars_pen <- out$pars_pen\n  #if(any(fit.ret2 == \"test\")==TRUE){\n  #  fits[[count]]$test = NA #fit_indices(out,CV=TRUE)[fit.ret]\n  #}else\n  if(fit.ret2 == \"train\"){\n    fitt = try(fit_indices(out,CV=FALSE)$fits[fit.ret],silent=T)\n    fit.reg[count] <- out$optim_fit\n    if(inherits(fitt, \"try-error\")) {\n      fits[count,3:ncol(fits)] = rep(NA,ncol(fits)-2)\n    }else{\n      fits[count,3:ncol(fits)] = fitt\n    }\n\n  }else if(fit.ret2 == \"test\"){\n   # stop(\"fit.ret2=test is currently not implemented\")\n    #print(summary(out))\n\n    fitt = try(fit_indices(out,CovMat=test.cov,CV=TRUE)$fits[fit.ret],silent=T)\n    if(inherits(fitt, \"try-error\")) {\n\n      fits[count,3:ncol(fits)] = rep(NA,ncol(fits)-2)\n    }else{\n\n      fits[count,3:ncol(fits)] = fitt\n    }\n  }\n  fits[count,1] <- SHRINK\n\n#  if(class(out$convergence)==\"numeric\"){\n  #print(class(out$convergence));print(1)\n  #print(out$convergence);print(class(out$convergence))\n    fits[count,2] <- out$convergence\n\n # }else{\n #   fits[count,2] <- 99\n    #out$convergence <- 99\n # }\n\n\n  if(is.null(out$coefficients)==TRUE){\n    break\n  }\n  par.matrix[count,] = as.matrix(out$coefficients)\n\n  colnames(par.matrix) = names(out$coefficients)\n  colnames(fits) <- c(\"lambda\",\"conv\",fit.ret)\n  fit.index = fits[,metric]\n  conv = fits[,\"conv\"]\n  loc = which(fit.index==min(fit.index[conv!=99 & is.na(conv)==FALSE]))\n  final_pars = par.matrix[loc,]\n\n  out2 <- list(par.matrix,fits,final_pars,pars_pen,metric) #fitt_var\n # ret\n\n}\n}else if(parallel==TRUE){\n\n  stop(\"Parallel is not currently supported\")\n\n  par.matrix <- matrix(0,n.lambda,model@Fit@npar)\n  fits <- matrix(NA,n.lambda,length(fit.ret)+2)\n  SHRINK = 0\n  count = 0\n  counts=n.lambda\n  #res2 <- data.frame(matrix(NA,counts,3))\n  #coefs = rep(1,14)\n\n  #library(snowfall)\n\n  cv_parallel <- function(SHRINK){\n\n    if(mult.start==FALSE){\n      out <- regsem(model=model,lambda=SHRINK,type=type,data=data,\n                    optMethod=optMethod,\n                    gradFun=gradFun,hessFun=hessFun,\n                    parallel=parallel,Start=Start,\n                    subOpt=subOpt,\n                    pars_pen=pars_pen,\n                    diff_par=diff_par,\n                    LB=LB,\n                    alpha=alpha,\n                    UB=UB,\n                    calc=calc,\n                    nlminb.control=nlminb.control,\n                    tol=tol,\n                    full=full,\n                    block=block,\n                    solver=solver,\n                    quasi=quasi,\n                    solver.maxit=solver.maxit,\n                    alpha.inc=alpha.inc,\n                    line.search=line.search,\n                    step=step,\n                    momentum=momentum,\n                    step.ratio=step.ratio,\n                    missing=missing)\n\n\n    }else if(mult.start==TRUE){\n      out <- multi_optim(model=model,max.try=multi.iter,lambda=SHRINK,\n                         LB=LB,UB=UB,type=type,optMethod=optMethod,\n                         gradFun=gradFun,hessFun=hessFun,nlminb.control=nlminb.control,\n                         tol=tol,\n                         full=full,\n                         alpha=alpha,\n                         block=block,\n                         solver=solver,\n                         quasi=quasi,\n                         solver.maxit=solver.maxit,\n                         alpha.inc=alpha.inc,\n                         step=step,\n                         line.search=line.search,\n                         momentum=momentum,\n                         step.ratio=step.ratio,\n                         pars_pen=pars_pen,diff_par=NULL,warm.start=warm.start)\n    }\n\n\n    #if(any(fit.ret2 == \"test\")==TRUE){\n    #  fits[[count]]$test = NA #fit_indices(out,CV=TRUE)[fit.ret]\n    #}else\n    if(fit.ret2 == \"train\"){\n      fitt = try(fit_indices(out,CV=FALSE)$fits[fit.ret],silent=T)\n      if(inherits(fitt, \"try-error\")) {\n        fitss = rep(NA,ncol(fits)-2)\n      }else{\n        fitss = fitt\n      }\n\n    }else if(fit.ret2 == \"test\"){\n      # stop(\"fit.ret2=test is currently not implemented\")\n      fitt = try(fit_indices(out,CovMat=test.cov,CV=TRUE)$fits[fit.ret],silent=T)\n      if(inherits(fitt, \"try-error\")) {\n        fitss = rep(NA,ncol(fits)-2)\n      }else{\n        fitss = fitt\n      }\n    }else if(fit.ret2 == \"boot\"){\n      fitt = try(fit_indices(out,CV=\"boot\")$fits[fit.ret],silent=T)\n      if(inherits(fitt, \"try-error\")) {\n        fitss = rep(NA,ncol(fits)-2)\n      }else{\n        fitss = fitt\n      }\n    }\n    fitss <- matrix(fitss,1,length(fit.ret))\n    data.frame(SHRINK,conv=out$convergence,fitss,out$coefficients)\n  }\n\n\n\n  snowfall::sfLibrary(regsem)\n  snowfall::sfInit(parallel=TRUE, cpus=ncore)\n  snowfall::sfExport(\"model\",\"type\",\"data\",\n                     \"optMethod\",\n                     \"gradFun\",\"hessFun\",\n                     \"parallel\",\"Start\",\n                     \"subOpt\",\n                     \"pars_pen\",\n                     \"diff_par\",\n                     \"LB\",\n                     \"block\",\n                     \"solver\",\n                     \"quasi\",\n                     \"full\",\n                     \"line.search\",\n                     \"UB\",\n                     \"calc\",\n                     \"nlminb.control\",\n                     \"warm.start\",\n                     \"missing\")\n\n\n\n\n  lambdas <- seq(0,by=jump,length.out=n.lambda)\n  ret = snowfall::sfLapply(lambdas,cv_parallel)\n  snowfall::sfStop()\n\n  #out\n  pars_pen <- out$pars_pen\n\n  out2 <- unlist(ret)\n  out2 <- matrix(out,nrow=n.lambda,ncol=length(ret[[1]]),byrow=T)\n  nam <- names(extractMatrices(model)$parameters)\n  colnames(out2) <- c(\"lambda\",\"conv\",fit.ret,nam)\n  out2\n\n\n\n}\n\n\n#fits = fit_indices(out,CV=FALSE)\n#out2$pars_pen <- pars_pen\nout2$call <- match.call()\nclass(out2) <- \"cvregsem\"\nnames(out2) <- c(\"parameters\",\"fits\",\"final_pars\",\"pars_pen\",\"metric\",\"call\")#\"fit_variance\"\nout2\n\n#close(pb)\n\n}\n",
    "created" : 1506527448234.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3721854692",
    "id" : "7BDCE884",
    "lastKnownWriteTime" : 1506457786,
    "last_content_update" : 1506457786,
    "path" : "~/GitHub/regsem/R/cv_regsem.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}