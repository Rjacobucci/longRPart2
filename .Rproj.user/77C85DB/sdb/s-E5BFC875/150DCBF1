{
    "collab_server" : "",
    "contents" : "#'\n#'\n#' Longitudinal Recursive Partitioning\n#'\n#'\n#' @param method Whether to use lme() or nlme(). Use either method=\"lme\" or method=\"nlme\".\n#'        This changes what additional arguments need to be passed.\n#' @param nlme.model Necessary to specify if method=\"nlme\"\n#' @param randomFormula Random effects to include for nlme() or lme()\n#' @param fixedFormula Fixed effects to include for nlme() or lme()\n#' @param data Dataset\n#' @param start Starting values for nlme()\n#' @param group Grouping for nlme()\n#' @param rPartFormula Not sure yet\n#' @param weight Sample weights to be passed to rpart\n#' @param R Correlation matrix to use for nlme. this is correlation=\n#' @param control Control function to be passed to rpart()\n#' @keywords longitudinal recursive partitioning mixed effects\n#' @import nlme\n#' @import rpart\n#' @import formula.tools\n#' @import MASS\n#' @import ggplot2\n#' @importFrom grDevices dev.cur gray rainbow\n#' @importFrom graphics legend plot points rect text\n#' @importFrom stats formula lm na.omit predict quantile rnorm time\n#' @export\n#' @examples\n#' library(longRPart2)\n#' # example goes here\n\n\nlongRPart2 <- function(method,\n                       nlme.model=NULL,\n                       randomFormula,\n                       fixedFormula=NULL,\n                       data,\n                       start,\n                       group,\n                       rPartFormula,\n                       weight=NULL,\n                       R=NULL,\n                       control = rpart.control()){\n\n\n  if(method==\"lme\"){\n    lmeFormula <- fixedFormula\n  }\n\n\n\n  if(method==\"lme\"){\n    groupingName = attr(terms(splitFormula(randomFormula,'|')[[2]]),\"term.labels\")\n    responseName = attr(terms(getResponseFormula(lmeFormula)),\"term.labels\")\n    groupingFactor = data[,names(data)==groupingName]\n    terms = attr(terms(lmeFormula),\"term.labels\")\n    continuous = !is.factor(data[,names(data)==terms[1]])\n    ### The 3 subfunctions necessary for rpart to work.\n    # The evaluation function.\n    # Called once per node:\n    # returns a list of two variables: a label for the node\n    # and a deviance value for the node.  The deviance is\n    # of length one, equal to 0 if the node is perfect/ unsplittable\n    # larger equals worse\n    evaluation <- function(y, wt, parms){\n      model = lme(lmeFormula,data=parms[groupingFactor%in%y,],random=randomFormula,correlation=R,na.action=na.omit)\n      if(continuous){\n        slope = model$coefficients$fixed[2]\n      }\n      else{\n        levels = length(levels(data[,names(data)==terms[1]]))\n        y=model$coefficients$fixed[1:levels]\n        x=1:levels\n        slope = lm(y~x)$coefficients[2]\n      }\n      list(label=slope,deviance=-2*(model$logLik))\n    }\n  }else if(method==\"nlme\"){\n    groupingName = attr(terms(splitFormula(group,'~')[[1]]),\"term.labels\")\n    responseName = attr(terms(getResponseFormula(nlme.model)),\"term.labels\")\n    groupingFactor = data[,names(data)==groupingName]\n\n      # need to deal with categorical vs. continuous\n\n    evaluation <- function(y, wt, parms){\n      model = nlme(model=nlme.model,fixed=fixedFormula,data=parms[groupingFactor%in%y,],\n                   random=randomFormula,correlation=R,na.action=na.omit,start=start,group=group)\n\n      # try not returning slope -- may be only for plotting\n      slope=1\n      list(label=slope,deviance=-2*(model$logLik))# ,pars=model$coefficients$fixed\n\n    }\n\n  }\n\n\n\n  # The split function, where the work occurs.  This is used to decide\n  # on the optimal split for a given covariate.\n  # Called once per split candidate per node\n  ### If the covariate, x, is continuous:\n  # x variable is ordered\n  # y is provided in the sort order of x\n  # returns two vectors of length (n-1)\n  #      goodness: goodness of the split, with larger numbers better. 0=no split\n  #      direction: -1 = send y < cutpoint to the left\n  #                  1 = send y < cutpoint to the right\n  #\n  ### If x is non-continuous\n  # x is a set of integers (NOT the original values) defining the\n  # groups for an unordered predictor.\n  # Again, return goodness and direction\n  #      direction: a vector of length m (number of groups), which is the applied\n  #                 ordering for the unordered categories.  This is done so that\n  #                 m-1 splits are performed, instead of all possible splits\n  #      goodness: m-1 values, same idea as before\n\n  ### pass in the dataset through the parms variable, with subj as y\n  split <- function(y, wt, x, parms, continuous){\n    print(paste(\"splitting:\",length(unique(x)),\"values\"))\n    dev = vector()\n    xUnique = unique(x)\n\n    if(method==\"lme\"){\n      rootDev = lme(lmeFormula,data=parms[groupingFactor%in%y,],random=randomFormula,correlation=R,na.action=na.omit)$logLik\n    }else if(method==\"nlme\"){\n      rootDev = nlme(model=nlme.model,fixed=fixedFormula,data=parms[groupingFactor%in%y,],\n                   random=randomFormula,correlation=R,na.action=na.omit,start=start,group=group)$logLik\n    }\n\n    #\n    # for continuous variables\n    #\n    if(continuous){\n      # need to find splits for the UNIQUE values of x\n      # no point in recalculating splits for the\n      # same age/height/etc...\n      for(i in xUnique){\n        yLeft = y[x<=i]\n        yRight = y[x>i]\n        # build the models only if the split created satisfies the minbucket.\n        # could add other split controls later\n        if(length(yLeft) < control$minbucket || length(yRight) < control$minbucket){\n          dev = c(dev,0)\n        }\n        else{\n          if(method==\"lme\"){\n            modelLeft = try(lme(lmeFormula,data=parms[groupingFactor%in%yLeft,],\n                                random=randomFormula,correlation=R,na.action=na.omit),silent=TRUE)\n            modelRight = try(lme(lmeFormula,data=parms[groupingFactor%in%yRight,],\n                                 random=randomFormula,correlation=R,na.action=na.omit),silent=TRUE)\n          }else if(method==\"nlme\"){\n            modelLeft = try(nlme(model=nlme.model,fixed=fixedFormula,data=parms[groupingFactor%in%yLeft,],\n                           random=randomFormula,correlation=R,na.action=na.omit,start=start,group=group),silent=TRUE)\n            modelRight = try(nlme(model=nlme.model,fixed=fixedFormula,data=parms[groupingFactor%in%yRight,],\n                                 random=randomFormula,correlation=R,na.action=na.omit,start=start,group=group),silent=TRUE)\n          }\n\n          if(any(class(modelLeft)=='lme')  &&\n             any(class(modelRight)=='lme') ){\n            dev = c(dev,modelLeft$logLik+modelRight$logLik)\n          }\n          else{\n            dev = c(dev,0)\n          }\n        }\n      }\n      # need to duplicate the observations for duplicate values of x\n      good = rep(0,length(x))\n      for(i in 1:length(xUnique)){\n        good[x==xUnique[i]]=dev[i]\n      }\n      good = good[1:(length(good)-1)]\n      list(goodness=good+abs(rootDev)*(good!=0)*2,direction=rep(-1,length(good)))\n    }\n    #\n    ###for categorical variables\n    #\n    else{\n      order = rep(0,length(xUnique))\n      response = parms[,names(parms)==responseName]\n      # establishing the ordering\n      for(i in 1:length(xUnique)){\n        order[i] = mean(response[x==xUnique[i]],na.rm=TRUE)\n      }\n      dir = sort(order,index.return=TRUE)$ix\n      # testing the direction\n      for(i in 1:(length(dir)-1)){\n        yLeft = y[x%in%dir[1:i]]\n        yRight = y[x%in%dir[(i+1):length(dir)]]\n        # build the models only if the split created satisfies the minbucket.\n        # could add other split controls later\n        if(length(yLeft) < control$minbucket || length(yRight) < control$minbucket){\n          dev = c(dev,0)\n        }\n        else{\n          if(method==\"lme\"){\n            modelLeft = try(lme(lmeFormula,data=parms[groupingFactor%in%yLeft,],\n                                random=randomFormula,correlation=R,na.action=na.omit),silent=TRUE)\n            modelRight = try(lme(lmeFormula,data=parms[groupingFactor%in%yRight,],\n                                 random=randomFormula,correlation=R,na.action=na.omit),silent=TRUE)\n          }else if(method==\"nlme\"){\n            modelLeft = try(nlme(model=nlme.model,fixed=fixedFormula,data=parms[groupingFactor%in%yLeft,],\n                                 random=randomFormula,correlation=R,na.action=na.omit,start=start,group=group),silent=TRUE)\n            modelRight = try(nlme(model=nlme.model,fixed=fixedFormula,data=parms[groupingFactor%in%yRight,],\n                                  random=randomFormula,correlation=R,na.action=na.omit,start=start,group=group),silent=TRUE)\n          }\n          if(any(class(modelLeft)=='lme') | any(class(modelLeft)=='nlme') &&\n             any(class(modelRight)=='lme') | any(class(modelRight)=='nlme')){\n            dev = c(dev,modelLeft$logLik+modelRight$logLik)\n          }\n          else{\n            dev = c(dev,0)\n          }\n        }\n      }\n      list(goodness=dev+abs(rootDev)*(dev!=0)*2,direction=dir)\n    }\n  }\n  # The init function.  This is used, to the best of my knowledge, to initialize the process.\n  # summary is used to fill print the report summary(model), and text is used to add text to\n  # the plot of the tree.\n  initialize <- function(y,offset,parms=0,wt){\n    list(\n      y=y,\n      parms=parms,\n      numresp=1,\n      numy=1,\n      summary=function(yval,dev,wt,ylevel,digits){paste(\"deviance (-2logLik)\",format(signif(dev),3),\"slope\",signif(yval,2))},\n      text= function(yval,dev,wt,ylevel,digits,n,use.n){\n        if(!use.n){paste(\"m:\",format(signif(yval,1)))}\n        else{paste(\"n:\",n)}\n      }\n    )\n  }\n  model <- list()\n  model.rpart = rpart(paste(groupingName,c(rPartFormula)),method=list(eval=evaluation,\n          split=split,init=initialize),control=control,data=data,parms=data)\n  model$rpart_out <- model.rpart\n\n  if(method==\"lme\"){\n    model$lmeModel = lme(lmeFormula,data=data,random=randomFormula,correlation=R,na.action=na.omit)\n    model$fixedFormula = lmeFormula\n    model$lmeFormula = lmeFormula\n  }else if(method==\"nlme\"){\n    model$nlmeModel <- nlme(model=nlme.model,fixed=fixedFormula,data=data,\n         random=randomFormula,correlation=R,na.action=na.omit,start=start,group=group)\n    model$fixedFormula <- fixedFormula\n    model$nlme.model <- nlme.model\n  }\n\n  model$leaf_node <- model.rpart$where\n  summary = fixed_effects = var.corr = resid.var = list()\n  for(j in 1:length(table(model.rpart$where))){\n    id <- names(table(model.rpart$where))[j]==model.rpart$where\n\n    if(method==\"lme\"){\n      model.out = lme(lmeFormula,data=data[id,],random=randomFormula,correlation=R,na.action=na.omit)\n      summary[[as.numeric(names(table(model.rpart$where)))[j]]] <- summary(model.out)\n      fixed_effects[[as.numeric(names(table(model.rpart$where)))[j]]] <- fixed.effects(model.out)\n      var.corr[[as.numeric(names(table(model.rpart$where)))[j]]] <-model.out$modelStruct[[1]]\n      resid.var[[as.numeric(names(table(model.rpart$where)))[j]]] <- model.out$sigma\n    }else if(method==\"nlme\"){\n      model.out <- nlme(model=nlme.model,fixed=fixedFormula,data=data[id,],\n                              random=randomFormula,correlation=R,na.action=na.omit,start=start,group=group)\n      summary[[as.numeric(names(table(model.rpart$where)))[j]]] <- summary(model.out)\n      fixed_effects[[as.numeric(names(table(model.rpart$where)))[j]]] <- fixed.effects(model.out)\n      var.corr[[as.numeric(names(table(model.rpart$where)))[j]]] <- model.out$modelStruct[[1]]\n      resid.var[[as.numeric(names(table(model.rpart$where)))[j]]] <- model.out$sigma\n    }\n  }\n\n  model$summary <- summary\n  model$fixed_effects <- fixed_effects\n  model$var.corr <- var.corr\n  model$resid.var <- resid.var\n  model$rpart_out <- model.rpart\n  model$randomFormula = randomFormula\n  model$R = R\n  model$method = method\n  model$data = data\n  model$groupingName = groupingName\n  model$rPartFormula = rPartFormula\n  return(model)\n}\n",
    "created" : 1488224986492.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "46706919",
    "id" : "150DCBF1",
    "lastKnownWriteTime" : 1488240304,
    "last_content_update" : 1488240304,
    "path" : "~/GitHub/longRPart2/R/longRPart2.R",
    "project_path" : "R/longRPart2.R",
    "properties" : {
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}