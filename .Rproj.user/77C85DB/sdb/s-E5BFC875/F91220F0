{
    "collab_server" : "",
    "contents" : "#'\n#'\n#' Longitudinal Recursive Partitioning Plotting Function\n#'\n#'\n#' @param model A longrpart2 model.\n#' @keywords longitudinal recursive partitioning mixed effects\n#' @export\n#' @examples\n#' library(longRPart2)\n#' # example goes here\n\nlrp2Plot = function(model){\n\n  #helper sub-functions\n  param.extract = function(model){ #extracts parameters from model to be used in calculations\n    grps = length(unique(model$leaf_node)) #number of nodes\n    fix.eff = model$fixed_effects[!sapply(model$fixed_effects, is.null)] #extract fixed-effects\n    res.var = model$resid.var[!sapply(model$resid.var, is.null)] #extract residual variances\n\n    #calculate covariance matrix of random-effects from correlation matrix output by nlme\n    varcov1 = model$var.corr[!sapply(model$var.corr, is.null)]\n    varcov = vector(\"list\",grps)\n    for(i in 1:grps){\n      varcov2 = corMatrix(varcov1[[i]])[[1]]\n      varcov[[i]] = varcov2*attr(varcov2, \"stdDev\")*res.var[[i]]*rep(attr(varcov2, \"stdDev\")*res.var[[i]],each=nrow(varcov2))\n      attr(varcov[[i]], \"stdDev\") = NULL\n    }\n\n    params = list(grps = grps, fix.eff = fix.eff, varcov = varcov, res.var = res.var)\n    return(params)\n  }\n  mean.traj = function(model, fix.eff){ #calculates mean trajectory for plot\n    times = seq(range(model$data$time)[1], range(model$data$time)[2], length.out=1000) #define time scores\n    #create data frame to use in calculation\n    if(model$method == \"lme\"){\n      envir.df = data.frame(matrix(nrow=length(times),ncol=length(fix.eff)+1))\n      colnames(envir.df) = c(\"time.scores\",names(fix.eff))\n      mean.est = numeric(nrow(envir.df))\n      envir.df[,1] = times\n      for(i in 1:nrow(envir.df)){\n        envir.df[i,2:ncol(envir.df)] = fix.eff\n        mean.est[i] = envir.df[i,2] + envir.df[i,3]*envir.df[i,1]\n      }\n      return(mean.est)\n    }\n    else if(model$method == \"nlme\"){\n      envir.df = data.frame(matrix(nrow=length(times),ncol=length(fix.eff)+1))\n      colnames(envir.df) = c(\"time\",lhs.vars(model$fixedFormula))\n      envir.df[,1] = times\n      for(i in 1:nrow(envir.df)){\n        envir.df[i,2:ncol(envir.df)] = fix.eff\n      }\n      mean.est = eval(getCovariateFormula(model$nlme.model)[[2]],envir.df) #evaluate model equation given times\n      return(mean.est)\n    }\n  }\n  conf.band = function(model, rand.eff, res.var){ #uses resampling to generate 95% confidence bands\n    times = seq(range(model$data$time)[1], range(model$data$time)[2], length.out=1000) #define time scores\n    cband = matrix(nrow=length(times),ncol=2)\n    resids = rnorm(nrow(rand.eff), 0, sqrt(res.var)) #generates residuals\n    #evaluates model equation a large number of times\n    #calculates empirical distribution of possible scores at each time point\n    #selects appropriate quantiles for 95% confidence band\n    if(model$method == \"lme\"){\n      for(i in 1:length(times)){\n        ys = rand.eff[,1] + rand.eff[,2]*times[i]\n        sort.ys = sort(ys)\n        cband[i,1] = sort.ys[nrow(rand.eff)*.025+1]\n        cband[i,2] = sort.ys[nrow(rand.eff)*.975]\n      }\n    }\n    else if(model$method == \"nlme\"){\n      for(i in 1:length(times)){\n        ys = eval(getCovariateFormula(model$nlme.model)[[2]],data.frame(time=times[i],rand.eff))+resids[i]\n        sort.ys = sort(ys)\n        cband[i,1] = sort.ys[nrow(rand.eff)*.025+1]\n        cband[i,2] = sort.ys[nrow(rand.eff)*.975]\n      }\n    }\n    return(cband)\n  }\n  curve.struc = function(model,grps,mean.est,cbands){\n    #data structure\n    curve.df = data.frame(matrix(nrow=3000*grps, ncol=4))\n    names(curve.df) = c(\"y\",\"grp\",\"time\",\"col\")\n    #score column\n    ycol=NULL\n    for(i in 1:grps){\n      ycol = c(ycol,mean.est[[i]],cbands[[i]][,1],cbands[[i]][,2])\n    }\n    curve.df$y = ycol\n    #groups (to distinguish each curve)\n    curve.df$grp = sort(rep(1:(3*grps),1000))\n    #time variable\n    times = seq(range(model$data$time)[1], range(model$data$time)[2], length.out=1000)\n    curve.df$time = rep(c(rep(times,3)),grps)\n    #colors\n    curve.df$col = as.factor(sort(rep(1:grps, 3000)))\n    return(curve.df)\n  }\n\n  #plotting function\n  set.seed(1234)\n  #change time variable's name to \"time\"\n  if(model$method == \"lme\"){\n    time.var = rhs.vars(model$fixedFormula)\n    out.name = lhs.vars(model$fixedFormula)\n  }\n  else if(model$method == \"nlme\"){\n    time.var = subset(rhs.vars(model$nlme.model), !(rhs.vars(model$nlme.model)%in%lhs.vars(model$fixedFormula)))\n    out.name = lhs.vars(model$nlme.model)\n  }\n  names(model$data)[which(names(model$data)==time.var)] = \"time\"\n\n  #extract group and parameter estimates\n  params = param.extract(model)\n\n  #generate mean trajectories and confidence bands\n  mean.est = rand.eff = cbands = vector(\"list\", params$grps)\n  for(i in 1:params$grps){\n    rand.eff[[i]] = mvrnorm(10000, mu=params$fix.eff[[i]], Sigma=params$varcov[[i]])\n    colnames(rand.eff[[i]]) = lhs.vars(model$randomFormula)\n    mean.est[[i]] = mean.traj(model, params$fix.eff[[i]])\n    cbands[[i]] = conf.band(model,rand.eff[[i]],params$res.var[[i]])\n  }\n  curve.df = curve.struc(model,params$grps,mean.est,cbands)\n\n  #plot\n  p = ggplot(data=curve.df,aes(x=time, y=y, group=grp, color=col)) +\n    geom_smooth(se=F) + theme_bw() +\n    labs(x = time.var, y = out.name, color = \"Node\\n\") + #\n    scale_color_manual(labels = sort(unique(model$leaf_node)), values = c(\"blue\", \"red\")) +\n    theme(\n      plot.background = element_blank()\n      ,panel.grid.major = element_blank()\n      ,panel.grid.minor = element_blank()\n      ,panel.border = element_blank()\n      ,axis.line.x = element_line(color=\"black\")\n      ,axis.line.y = element_line(color=\"black\")\n      ,legend.position=\"right\")\n\n  return(p)\n}\n",
    "created" : 1488225017794.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2624471964",
    "id" : "F91220F0",
    "lastKnownWriteTime" : 1488241165,
    "last_content_update" : 1488241165386,
    "path" : "~/GitHub/longRPart2/R/lrp2Plot.R",
    "project_path" : "R/lrp2Plot.R",
    "properties" : {
    },
    "relative_order" : 8,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}