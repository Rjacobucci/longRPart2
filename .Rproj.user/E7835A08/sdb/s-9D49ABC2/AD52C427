{
    "collab_server" : "",
    "contents" : "#\n# trying to cross-validate\n#\nlrpCV <- function(model){\n  #  set.seed(2)\n  # extracting the rpart-values\n  dat <- model$data\n  control <- model$control\n  evaluation = model$functions$eval\n  split = model$functions$split\n  initialize = model$functions$init\n  groupingName = model$groupingName\n  rPartFormula = model$rPartFormula\n  v <- model$control$xval\n  if(v < 2)\n    stop(\"cannot cross-validate with fewer than 2 folds.\")\n  n = length(unique(dat[,groupingName]))\n  deviances <- data.frame(matrix(nrow=n,ncol=2))\n  names(deviances) <- c(groupingName,'deviance')\n  z = 1\n  subj = sample(unique(dat[,groupingName]),n,replace=FALSE)\n  stepsize = rep(floor(length(subj)/v),v)\n  remainder = n-sum(stepsize)\n  add = sample(1:v,remainder,replace=FALSE)\n  stepsize = c(0,cumsum(stepsize + (1:v)%in%add))\n  for(i in 1:v){\n    testDat = dat[dat[,groupingName]%in%subj[(stepsize[i]+1):stepsize[i+1]],]\n    data = dat[!dat[,groupingName]%in%subj[(stepsize[i]+1):stepsize[i+1]],]\n    mod <- longRPart2(model$lmeFormula,model$rPartFormula,model$randomFormula,data,R=model$R,control=model$control)\n    pred = predict(mod,testDat)\n    # need to get the predicted lines at each node,\n    # NOT just the regression coefficient\n    terms = attr(terms(mod$lmeFormula),\"term.labels\")\n    timeVar = data[,names(data)==terms[1]]\n    responseName = attr(terms(getResponseFormula(mod$lmeFormula)),\"term.labels\")\n    continuous = !is.factor(timeVar)\n    nodes = unique(mod$where)\n    timeValues = unique(timeVar)\n    for(j in 1:length(nodes)){\n      subData = data[mod$where==nodes[j],]\n      subTest = testDat[pred==mod$frame$yval[nodes[j]],]\n      mod2 <- lme(mod$lmeFormula,data=subData,random=mod$randomFormula,correlation=mod$R,na.action=na.omit)\n      responseName = attr(terms(getResponseFormula(model$lmeFormula)),\"term.labels\")\n      for(k in unique(subTest[,names(subTest)==mod$groupingName])){\n        observed <- subTest[subTest[,names(subTest)==mod$groupingName]==k,]\n        # creating the fake patient (PROBLEMS HERE)\n        # Things needed to be fixed:\n        # 1. deal with non-standard time intervals\n        # 2. deal with confounding\n        expected <- observed\n        expected[,names(expected)==mod$groupingName] <- -1\n        subTimeVar <- unique(sort(mod2$data[!is.na(mod2$data[,names(mod2$data)==responseName]),names(mod2$data)==terms[1]]))\n        expected[expected[,names(expected)==terms[[1]]]%in%subTimeVar,names(expected)==responseName] = as.vector(mod2$coeff$fixed)\n        mod3 = lme(mod$lmeFormula,data=rbind(observed,expected),random=mod$randomFormula,correlation=mod$R,na.action=na.omit)\n        deviances[z,] <- c(k,-2*mod3$logLik)\n        z = z+1\n      }\n    }\n  }\n  deviances\n}\n\n# Calculate a confidence interval for the first split using bootstrapping\n#\n#\nlrpCI <- function(model,B=10,alpha=0.05){\n  # idea is to take B bootstrap samples of size n, getting an optimal spliting\n  # value at each node.  The CI makes sense for the first split, but for the\n  # rest of the splits it is not as intuitive.  !!!For now, we'll just use the\n  # first split, and discuss other options later\n  R = model$R\n  evaluation = model$functions$eval\n  split = model$functions$split\n  initialize = model$functions$init\n  models = list()\n  splitVal = rep(0,B)\n  newControl = model$control\n  newControl$maxdepth = 1\n  newControl$cp=0\n  n=length(unique(model$data[,model$groupingName]))\n  for(b in 1:B){\n    ind = sample(1:n,n,replace=TRUE)\n    newDat = model$data[model$data[,model$groupingName]==ind[1],]\n    newDat[,names(newDat)==model$groupingName] = rep(1,dim(newDat)[1])\n    for(i in 2:n){\n      tempDat = model$data[model$data[,model$groupingName]==ind[i],]\n      tempDat[,names(newDat)==model$groupingName] = rep(i,dim(tempDat)[1])\n      newDat = rbind(newDat,tempDat)\n    }\n    newDat[,names(newDat)==model$groupingName]=as.factor(newDat[,names(newDat)==model$groupingName])\n    newModel = rpart(paste(model$groupingName,\"~\",row.names(model$splits)[1]),data=newDat,method=list(eval=evaluation,split=split,init=initialize),parms=model$data,control=newControl)\n    models[[b]]=newModel\n    if(!is.null(newModel$splits)){\n      splitVal[b] = newModel$splits[1,4]\n    }\n    else{\n      splitVal[b] = NA\n    }\n  }\n  return(list(CI=quantile(splitVal,probs=seq(alpha/2,1-alpha/2,length.out=2),na.rm=TRUE),splitVal))\n}\n\n#\n#\n# Calculate the p-value using a permutation test\n#\n#\nlrpPVal <- function(model,J){\n  # idea is to permute the predictor while holding the response\n  # fixed.  Do this J times, and then the proportion of improvements in deviance\n  # that are better than the observed improvement is the p-val\n  R = model$R\n  Dobs = model$frame$dev[1] - (model$frame$dev[row.names(model$frame)==2]+model$frame$dev[row.names(model$frame)==3])\n  evaluation = model$functions$eval\n  split = model$functions$split\n  initialize = model$functions$init\n  models = list()\n  D = rep(0,J)\n  DFirst = rep(0,J)\n  sub = length(unique(model$data[,model$groupingName]))\n  newControl = model$control\n  newControl$maxdepth=1\n  for(j in 1:J){\n    newDat = model$data\n    ind = match(match(newDat[,model$groupingName],sample(1:sub,sub,replace=FALSE)),newDat[,model$groupingName])\n    newDat[,names(newDat)==row.names(model$splits)[1]] = newDat[ind,names(newDat)==row.names(model$splits)[1]]\n    newModel = rpart(paste(model$groupingName,\"~\",row.names(model$splits)[1]),data=newDat,method=list(eval=evaluation,split=split,init=initialize),parms=model$data,control=newControl)\n    D[j] = newModel$frame$dev[1] - newModel$frame$dev[2] - newModel$frame$dev[3]\n    models[[j]] = newModel\n  }\n  return(list(Dobs,D))\n}\n",
    "created" : 1481468078070.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1998432775",
    "id" : "AD52C427",
    "lastKnownWriteTime" : 1481566469,
    "last_content_update" : 1481566469101,
    "path" : "~/GitHub/longRPart2/R/analysis.R",
    "project_path" : "R/analysis.R",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}