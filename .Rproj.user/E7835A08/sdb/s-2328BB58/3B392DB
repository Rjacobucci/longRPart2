{
    "collab_server" : "",
    "contents" : "#'\n#'\n#' Longitudinal Recursive Partitioning\n#'\n#'\n#' @param method Whether to use lme() or nlme(). Use either method=\"lme\" or method=\"nlme\".\n#'        This changes what additional arguments need to be passed.\n#' @param model Necessary to specify if method=\"nlme\"\n#' @param randomFormula Random effects to include for nlme() or lme()\n#' @param fixedFormula Fixed effects to include for nlme() or lme()\n#' @param data Dataset\n#' @param rPartFormula Not sure yet\n#' @param weight Sample weights to be passed to rpart\n#' @param R Correlation matrix to use for nlme. this is correlation=\n#' @param control Control function to be passed to rpart()\n#' @keywords longitudinal recursive partitioning mixed effects\n#' @import nlme\n#' @import rpart\n#' @importFrom grDevices dev.cur gray rainbow\n#' @importFrom graphics legend plot points rect text\n#' @importFrom stats formula lm na.omit predict quantile\n#' @export\n#' @examples\n#' library(longRPart2)\n#' # example goes here\n\n\nlongRPart2 <- function(method,\n                       model=NULL,\n                       randomFormula,\n                       fixedFormula=NULL,\n                       data,\n                       rPartFormula,\n                       weight=NULL,\n                       R=NULL,\n                       control = rpart.control()){\n\n\n  if(method==\"lme\"){\n    lmeFormula <- fixedFormula\n  }\n\n\n\n  groupingName = attr(terms(splitFormula(randomFormula,'|')[[2]]),\"term.labels\")\n  responseName = attr(terms(getResponseFormula(lmeFormula)),\"term.labels\")\n  groupingFactor = data[,names(data)==groupingName]\n  terms = attr(terms(lmeFormula),\"term.labels\")\n  continuous = !is.factor(data[,names(data)==terms[1]])\n  ### The 3 subfunctions necessary for rpart to work.\n  # The evaluation function.\n  # Called once per node:\n  # returns a list of two variables: a label for the node\n  # and a deviance value for the node.  The deviance is\n  # of length one, equal to 0 if the node is perfect/ unsplittable\n  # larger equals worse\n  evaluation <- function(y, wt, parms){\n    model = lme(lmeFormula,data=parms[groupingFactor%in%y,],random=randomFormula,correlation=R,na.action=na.omit)\n    if(continuous){\n      slope = model$coefficients$fixed[2]\n    }\n    else{\n      levels = length(levels(data[,names(data)==terms[1]]))\n      y=model$coefficients$fixed[1:levels]\n      x=1:levels\n      slope = lm(y~x)$coefficients[2]\n    }\n    list(label=slope,deviance=-2*(model$logLik))\n  }\n\n  # The split function, where the work occurs.  This is used to decide\n  # on the optimal split for a given covariate.\n  # Called once per split candidate per node\n  ### If the covariate, x, is continuous:\n  # x variable is ordered\n  # y is provided in the sort order of x\n  # returns two vectors of length (n-1)\n  #      goodness: goodness of the split, with larger numbers better. 0=no split\n  #      direction: -1 = send y < cutpoint to the left\n  #                  1 = send y < cutpoint to the right\n  #\n  ### If x is non-continuous\n  # x is a set of integers (NOT the original values) defining the\n  # groups for an unordered predictor.\n  # Again, return goodness and direction\n  #      direction: a vector of length m (number of groups), which is the applied\n  #                 ordering for the unordered categories.  This is done so that\n  #                 m-1 splits are performed, instead of all possible splits\n  #      goodness: m-1 values, same idea as before\n\n  ### pass in the dataset through the parms variable, with subj as y\n  split <- function(y, wt, x, parms, continuous){\n    print(paste(\"splitting:\",length(unique(x)),\"values\"))\n    dev = vector()\n    xUnique = unique(x)\n    rootDev = lme(lmeFormula,data=parms[groupingFactor%in%y,],random=randomFormula,correlation=R,na.action=na.omit)$logLik\n    #\n    # for continuous variables\n    #\n    if(continuous){\n      # need to find splits for the UNIQUE values of x\n      # no point in recalculating splits for the\n      # same age/height/etc...\n      for(i in xUnique){\n        yLeft = y[x<=i]\n        yRight = y[x>i]\n        # build the models only if the split created satisfies the minbucket.\n        # could add other split controls later\n        if(length(yLeft) < control$minbucket || length(yRight) < control$minbucket){\n          dev = c(dev,0)\n        }\n        else{\n          modelLeft = try(lme(lmeFormula,data=parms[groupingFactor%in%yLeft,],random=randomFormula,correlation=R,na.action=na.omit),silent=TRUE)\n          modelRight = try(lme(lmeFormula,data=parms[groupingFactor%in%yRight,],random=randomFormula,correlation=R,na.action=na.omit),silent=TRUE)\n          if(class(modelLeft)=='lme' && class(modelRight)=='lme'){\n            dev = c(dev,modelLeft$logLik+modelRight$logLik)\n          }\n          else{\n            dev = c(dev,0)\n          }\n        }\n      }\n      # need to duplicate the observations for duplicate values of x\n      good = rep(0,length(x))\n      for(i in 1:length(xUnique)){\n        good[x==xUnique[i]]=dev[i]\n      }\n      good = good[1:(length(good)-1)]\n      list(goodness=good+abs(rootDev)*(good!=0)*2,direction=rep(-1,length(good)))\n    }\n    #\n    ###for categorical variables\n    #\n    else{\n      order = rep(0,length(xUnique))\n      response = parms[,names(parms)==responseName]\n      # establishing the ordering\n      for(i in 1:length(xUnique)){\n        order[i] = mean(response[x==xUnique[i]],na.rm=TRUE)\n      }\n      dir = sort(order,index.return=TRUE)$ix\n      # testing the direction\n      for(i in 1:(length(dir)-1)){\n        yLeft = y[x%in%dir[1:i]]\n        yRight = y[x%in%dir[(i+1):length(dir)]]\n        # build the models only if the split created satisfies the minbucket.\n        # could add other split controls later\n        if(length(yLeft) < control$minbucket || length(yRight) < control$minbucket){\n          dev = c(dev,0)\n        }\n        else{\n          modelLeft = try(lme(lmeFormula,data=parms[groupingFactor%in%yLeft,],random=randomFormula,correlation=R,na.action=na.omit),silent=TRUE)\n          modelRight = try(lme(lmeFormula,data=parms[groupingFactor%in%yRight,],random=randomFormula,correlation=R,na.action=na.omit),silent=TRUE)\n          if(class(modelLeft)=='lme' && class(modelRight)=='lme'){\n            dev = c(dev,modelLeft$logLik+modelRight$logLik)\n          }\n          else{\n            dev = c(dev,0)\n          }\n        }\n      }\n      list(goodness=dev+abs(rootDev)*(dev!=0)*2,direction=dir)\n    }\n  }\n  # The init function.  This is used, to the best of my knowledge, to initialize the process.\n  # summary is used to fill print the report summary(model), and text is used to add text to\n  # the plot of the tree.\n  initialize <- function(y,offset,parms=0,wt){\n    list(\n      y=y,\n      parms=parms,\n      numresp=1,\n      numy=1,\n      summary=function(yval,dev,wt,ylevel,digits){paste(\"deviance (-2logLik)\",format(signif(dev),3),\"slope\",signif(yval,2))},\n      text= function(yval,dev,wt,ylevel,digits,n,use.n){\n        if(!use.n){paste(\"m:\",format(signif(yval,1)))}\n        else{paste(\"n:\",n)}\n      }\n    )\n  }\n\n  model = rpart(paste(groupingName,c(rPartFormula)),method=list(eval=evaluation,split=split,init=initialize),control=control,data=data,parms=data)\n  model$lmeModel = lme(lmeFormula,data=data,random=randomFormula,correlation=R,na.action=na.omit)\n  model$lmeFormula = lmeFormula\n  model$randomFormula = randomFormula\n  model$R = R\n  model$data = data\n  model$groupingName = groupingName\n  model$rPartFormula = rPartFormula\n  return(model)\n}\n",
    "created" : 1481466882923.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3580876262",
    "id" : "3B392DB",
    "lastKnownWriteTime" : 1481566253,
    "last_content_update" : 1481566253593,
    "path" : "~/GitHub/longRPart2/R/longRPart2.R",
    "project_path" : "R/longRPart2.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}