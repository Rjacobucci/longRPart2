{
    "collab_server" : "",
    "contents" : "#SCCS @(#)rpartco.s\t1.7 02/07/00\n# Compute the x-y coordinates for a tree\nrpartco <- function(tree, parms =  paste(\".rpart.parms\", dev.cur(), sep = \".\"))\n    {\n\n    frame <- tree$frame\n    node <- as.numeric(row.names(frame))\n    depth <- tree.depth(node)\n    is.leaf <- (frame$var == '<leaf>')\n    if (exists(parms, envir=.GlobalEnv)) {\n\tparms <- get(parms, envir=.GlobalEnv)\n\tuniform <- parms$uniform\n\tnspace <-parms$nspace\n\tminbranch <- parms$minbranch\n\t}\n    else {\n\tuniform <- FALSE\n\tnspace <- -1\n\tminbranch <- .3\n        }\n\n    if(uniform) y <- (1 + max(depth) -depth) / max(depth,4)\n    else {                    #make y- (parent y) = change in deviance\n\ty <- dev <- frame$dev\n        temp <- split(seq(node), depth)     #depth 0 nodes, then 1, then ...\n        parent <- match(floor(node/2), node)\n        sibling <- match(ifelse(node %% 2, node - 1, node + 1), node)\n\n\t# assign the depths\n        for(i in temp[-1]) {\n\t    temp2 <- dev[parent[i]] - (dev[i] + dev[sibling[i]])\n            y[i] <- y[parent[i]] - temp2\n\t    }\n\t#\n\t# For some problems, classification & loss matrices in particular\n\t#   the gain from a split may be 0.  This is ugly on the plot.\n\t# Hence the \"fudge\" factor of  .3* the average step\n\t#\n\tfudge <-  minbranch * diff(range(y)) / max(depth)\n        for(i in temp[-1]) {\n\t    temp2 <- dev[parent[i]] - (dev[i] + dev[sibling[i]])\n\t    haskids <- !(is.leaf[i] & is.leaf[sibling[i]])\n\t    y[i] <- y[parent[i]] - ifelse(temp2<=fudge & haskids, fudge, temp2)\n\t    }\n\ty <- y / (max(y))\n        }\n\n    # Now compute the x coordinates, by spacing out the leaves and then\n    #   filling in\n    x   <-  double(length(node))         #allocate, then fill it in below\n    x[is.leaf] <- seq(sum(is.leaf))      # leaves at 1, 2, 3, ....\n    left.child <- match(node * 2, node)\n    right.child <- match(node * 2 + 1, node)\n\n    # temp is a list of non-is.leaf, by depth\n    temp <- split(seq(node)[!is.leaf], depth[!is.leaf])\n    for(i in rev(temp))\n            x[i] <- 0.5 * (x[left.child[i]] + x[right.child[i]])\n\n    if (nspace < 0) return(list(x=x, y=y))\n\n    #\n    # Now we get fancy, and try to do overlapping\n    #\n    #  The basic algorithm is, at each node:\n    #      1: get the left & right edges, by depth, for the left and\n    #           right sons, of the x-coordinate spacing.\n    #      2: find the minimal free spacing.  If this is >0, slide the\n    #           right hand son over to the left\n    #      3: report the left & right extents of the new tree up to the\n    #           parent\n    #   A way to visualize steps 1 and 2 is to imagine, for a given node,\n    #      that the left son, with all its descendants, is drawn on a\n    #      slab of wood.  The left & right edges, per level, give the\n    #      width of this board.  (The board is not a rectangle, it has\n    #      'stair step' edges). Do the same for the right son.  Now\n    #      insert some spacers, one per level, and slide right hand\n    #      board over until they touch.  Glue the boards and spacer\n    #      together at that point.\n    #\n    #  If a node has children, its 'space' is considered to extend left\n    #    and right by the amount \"nspace\", which accounts for space\n    #    used by the arcs from this node to its children.  For\n    #    horseshoe connections nspace usually is 1.\n    #\n    #  To make it global for a recursive function, the x coordinate list\n    #    is written into frame 0.\n    #\n    compress <- function(me, depth) {\n        lson <- me +1\n\tx <- x\n\tif (is.leaf[lson]) left <- list(left=x[lson], right=x[lson],\n\t\t\t\t\t\tdepth=depth+1, sons=lson)\n        else               left <- compress(me+1, depth+1)\n\n        rson <- me + 1 + length(left$sons)        #index of right son\n\tif (is.leaf[rson]) right<- list(left=x[rson], right=x[rson],\n\t\t\t\t\t\tdepth=depth+1, sons=rson)\n\telse               right<- compress(rson, depth+1)\n\n\tmaxd <- max(left$depth, right$depth) - depth\n        mind <- min(left$depth, right$depth) - depth\n\n\t# Find the smallest distance between the two subtrees\n\t#   But only over depths that they have in common\n\t# 1 is a minimum distance allowed\n\tslide <- min(right$left[1:mind] - left$right[1:mind]) -1\n\tif (slide >0) { # slide the right hand node to the left\n\t    x[right$sons] <- x[right$sons] - slide;\n\t    x[me] <- (x[right$sons[1]] + x[left$sons[1]])/2\n#\t    assign(\"x\", x)\n            x <<- x\n\t    }\n\telse slide <- 0\n\n\t# report back\n        if (left$depth > right$depth) {\n\t    templ <- left$left\n            tempr <- left$right\n            tempr[1:mind] <- pmax(tempr[1:mind], right$right -slide)\n\t    }\n        else {\n\t    templ <- right$left  - slide\n\t    tempr <- right$right - slide\n\t    templ[1:mind] <- pmin(templ[1:mind], left$left)\n\t    }\n\n\tlist(left = c(x[me]- nspace*(x[me] -x[lson]), templ),\n\t     right= c(x[me]- nspace*(x[me] -x[rson]), tempr),\n\t     depth= maxd+ depth, sons=c(me, left$sons, right$sons))\n\t}\n#    assign('compress', compress)\n#    assign('x', x)\n#    assign('is.leaf', is.leaf)\n#    assign('nspace', nspace)\n\n#    temp <-\n    compress(1, 1)\n#    x <- get('x')\n#    remove(c('compress', 'x', 'is.leaf', 'nspace'))\n    list(x = x, y = y)\n}\n\ntree.depth <- function (nodes)\n{\n    depth <- floor(log(nodes, base = 2) + 1e-7)\n    as.vector(depth - min(depth))\n}\n\n",
    "created" : 1481465807814.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2171069551",
    "id" : "31CBBFBB",
    "lastKnownWriteTime" : 1203617476,
    "last_content_update" : 1203617476,
    "path" : "~/GitHub/longRPart2/R/subFunctions.R",
    "project_path" : "R/subFunctions.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}