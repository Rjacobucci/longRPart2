{
    "collab_server" : "",
    "contents" : "#library(rpart)\n#library(nlme)\n#\n#\n# Tree Building Function\n#\n#\nlongRPart <- function(lmeFormula,rPartFormula,randomFormula,data,weight=NULL,R=NULL,control = rpart.control()){\n    groupingName = attr(terms(splitFormula(randomFormula,'|')[[2]]),\"term.labels\")\n    responseName = attr(terms(getResponseFormula(lmeFormula)),\"term.labels\")\n    groupingFactor = data[,names(data)==groupingName]\n    terms = attr(terms(lmeFormula),\"term.labels\")\n    continuous = !is.factor(data[,names(data)==terms[1]])\n    ### The 3 subfunctions necessary for rpart to work.\n    # The evaluation function.\n    # Called once per node:\n    # returns a list of two variables: a label for the node\n    # and a deviance value for the node.  The deviance is\n    # of length one, equal to 0 if the node is perfect/ unsplittable\n    # larger equals worse\n    evaluation <- function(y, wt, parms){\n      model = lme(lmeFormula,data=parms[groupingFactor%in%y,],random=randomFormula,correlation=R,na.action=na.omit)\n      if(continuous){\n        slope = model$coefficients$fixed[2]\n      }\n      else{\n        levels = length(levels(data[,names(data)==terms[1]]))\n        y=model$coefficients$fixed[1:levels]\n        x=1:levels\n        slope = lm(y~x)$coefficients[2]\n      }\n      list(label=slope,deviance=-2*(model$logLik))\n    }\n\n    # The split function, where the work occurs.  This is used to decide \n    # on the optimal split for a given covariate.\n    # Called once per split candidate per node\n    ### If the covariate, x, is continuous:\n    # x variable is ordered\n    # y is provided in the sort order of x\n    # returns two vectors of length (n-1)\n    #      goodness: goodness of the split, with larger numbers better. 0=no split\n    #      direction: -1 = send y < cutpoint to the left\n    #                  1 = send y < cutpoint to the right\n    #\n    ### If x is non-continuous\n    # x is a set of integers (NOT the original values) defining the\n    # groups for an unordered predictor.\n    # Again, return goodness and direction\n    #      direction: a vector of length m (number of groups), which is the applied\n    #                 ordering for the unordered categories.  This is done so that\n    #                 m-1 splits are performed, instead of all possible splits\n    #      goodness: m-1 values, same idea as before\n\n    ### pass in the dataset through the parms variable, with subj as y\n    split <- function(y, wt, x, parms, continuous){\n      print(paste(\"splitting:\",length(unique(x)),\"values\"))\n      dev = vector()\n      xUnique = unique(x)\n      rootDev = lme(lmeFormula,data=parms[groupingFactor%in%y,],random=randomFormula,correlation=R,na.action=na.omit)$logLik\n      #\n      # for continuous variables\n      # \n      if(continuous){\n        # need to find splits for the UNIQUE values of x\n        # no point in recalculating splits for the\n        # same age/height/etc...\n        for(i in xUnique){\n          yLeft = y[x<=i]\n          yRight = y[x>i]\n          # build the models only if the split created satisfies the minbucket.\n          # could add other split controls later\n          if(length(yLeft) < control$minbucket || length(yRight) < control$minbucket){\n            dev = c(dev,0)\n          }\n          else{\n            modelLeft = try(lme(lmeFormula,data=parms[groupingFactor%in%yLeft,],random=randomFormula,correlation=R,na.action=na.omit),silent=TRUE)\n            modelRight = try(lme(lmeFormula,data=parms[groupingFactor%in%yRight,],random=randomFormula,correlation=R,na.action=na.omit),silent=TRUE)\n            if(class(modelLeft)=='lme' && class(modelRight)=='lme'){\n              dev = c(dev,modelLeft$logLik+modelRight$logLik)\n            }\n            else{\n              dev = c(dev,0)\n            }\n          }\n        }\n        # need to duplicate the observations for duplicate values of x\n        good = rep(0,length(x))\n        for(i in 1:length(xUnique)){\n          good[x==xUnique[i]]=dev[i]\n        }\n        good = good[1:(length(good)-1)]\n        list(goodness=good+abs(rootDev)*(good!=0)*2,direction=rep(-1,length(good)))\n      }\n      #\n      ###for categorical variables\n      #\n      else{\n        order = rep(0,length(xUnique))\n        response = parms[,names(parms)==responseName]\n        # establishing the ordering\n        for(i in 1:length(xUnique)){\n          order[i] = mean(response[x==xUnique[i]],na.rm=TRUE)\n        }\n        dir = sort(order,index.return=TRUE)$ix\n        # testing the direction\n        for(i in 1:(length(dir)-1)){\n          yLeft = y[x%in%dir[1:i]]\n          yRight = y[x%in%dir[(i+1):length(dir)]]\n          # build the models only if the split created satisfies the minbucket.\n          # could add other split controls later\n          if(length(yLeft) < control$minbucket || length(yRight) < control$minbucket){\n            dev = c(dev,0)\n          }\n          else{\n            modelLeft = try(lme(lmeFormula,data=parms[groupingFactor%in%yLeft,],random=randomFormula,correlation=R,na.action=na.omit),silent=TRUE)\n            modelRight = try(lme(lmeFormula,data=parms[groupingFactor%in%yRight,],random=randomFormula,correlation=R,na.action=na.omit),silent=TRUE)\n            if(class(modelLeft)=='lme' && class(modelRight)=='lme'){\n              dev = c(dev,modelLeft$logLik+modelRight$logLik)\n            }\n            else{\n              dev = c(dev,0)\n            }\n          }\n        }\n        list(goodness=dev+abs(rootDev)*(dev!=0)*2,direction=dir)\n      }\n    }\n    # The init function.  This is used, to the best of my knowledge, to initialize the process.\n    # summary is used to fill print the report summary(model), and text is used to add text to\n    # the plot of the tree.\n    initialize <- function(y,offset,parms=0,wt){\n      list(\n           y=y,\n           parms=parms,\n           numresp=1,\n           numy=1,\n           summary=function(yval,dev,wt,ylevel,digits){paste(\"deviance (-2logLik)\",format(signif(dev),3),\"slope\",signif(yval,2))},\n           text= function(yval,dev,wt,ylevel,digits,n,use.n){\n             if(!use.n){paste(\"m:\",format(signif(yval,1)))}\n             else{paste(\"n:\",n)}\n           }\n          )\n    }\n    \n    model = rpart(paste(groupingName,c(rPartFormula)),method=list(eval=evaluation,split=split,init=initialize),control=control,data=data,parms=data)\n    model$lmeModel = lme(lmeFormula,data=data,random=randomFormula,correlation=R,na.action=na.omit)\n    model$lmeFormula = lmeFormula\n    model$randomFormula = randomFormula\n    model$R = R\n    model$data = data\n    model$groupingName = groupingName\n    model$rPartFormula = rPartFormula\n    return(model)\n  }\n    \n",
    "created" : 1481465793599.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2125953105",
    "id" : "B8DBDA1F",
    "lastKnownWriteTime" : 1229544568,
    "last_content_update" : 1229544568,
    "path" : "~/GitHub/longRPart2/R/longRPart.R",
    "project_path" : "R/longRPart.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}